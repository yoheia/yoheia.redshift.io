## 目次
- 本書の俯瞰図
	- SQLチューニングマスターへの最短ルート
- 原理と前提知識
	- SQLを速くするたった3つの原則
		- SQLの速さはデータ量ではなく仕事量で決まる
		- 速くする方法は3つしかない
			- 仕事量を減らす
			- 並列化する
			- 高速化する
		- 仕事量を減らせば速くなる
			- データ構造重要
			- フルスキャンは悪ではない
			- ユニークスキャンは一定、フルスキャンは足算、結合は掛け算
		- 仕事量削減で解決しない場合は並列化と高速化
			- 並列化が効くのは単純で大きなタスク
			- 最後はデータを速いところにおく高速化
	- SQL実行の流れ
		- 絵で見るSQL実行の流れ
		- 統計情報は実行計画作成にどう使われるか
		- 統計情報を超えた最適化
	- SQLチューニングの流れ
		- 推測するな計測せよ
			- 実行計画からでなく時間からスタートする
		- ボトルネックを見つける
			- 何に時間がかかっているか特定する
			- 実行計画のどの操作で時間がかかっているか特定する
		- ボトルネックを取り除く
			- アプローチ
				- 仕事量を減らす
				- 並列化
				- 高速化
			- 手段
				- 統計情報を収集する
				- SQLを書換える
				- データ構造を変える
				- ヒントなどで人為的に実行計画を操作する
		- チューニング結果を評価する
			- 実行時間と仕事量で評価する
			- データ量増加時の性能劣化を考慮する

- ボトルネックを特定する
	- 時間・仕事量・実行計画を計測する
	- 実行時間の内訳を見る(DB Time + AP Time + N/W Time)
	- どの処理で時間がかかっているか特定する(実行計画のどの操作か)

- 仕事量を減らすチューニング
	- 行方向で絞る
		- ソートキーの設計
	- 列方向で絞る
		- カバリング・インデックス
		- DBIM
	- 圧縮
	- 再利用・省略
		- 索引によるソート省略
		- コネクションプーリング(接続再利用)
		- バインド変数(ハードパース省略)
		- セッション・カーソル・キャッシュ(ソフトパース省略)
		- フェッチ・サイズを大きくしてラウンドトップ回数を減らす
		- バルク処理でまとめる

- 並列化によるチューニング
	- ノード数を増やす
	- Concurrency Scaling

- 高速化によるチューニング
	- ノード間通信を減らす
		- 分散キーの設計 
	- Result caching

- TIPS
	- [VACUUM](vacuum.md)